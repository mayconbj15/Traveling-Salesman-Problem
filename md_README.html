<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Travelling_Salesman_Algorithms: Traveling-Salesman-Problem</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Travelling_Salesman_Algorithms
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Gerado por Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Localizar');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Localizar');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Traveling-Salesman-Problem </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>1) Introdução:</h2>
<p>Em consonância com a expansão do mercado tecnológico, a complexidade dos problemas computacionais tem aumentado, o que implicou na busca de máquinas mais potentes para processá-los. Entretanto, tais recursos são limitados e por isso devem ser utilizados de maneira eficiente. Tendo em vista esta problemática e com o objetivo de destacar a importância do projeto e análise de algoritmos, o grupo propôs uma análise de quatro soluções distintas para um problema clássico da Ciência da Computação, o Problema do Caixeiro Viajante (Traveling Salesman Problem). Os algoritmos utilizados foram:</p>
<ul>
<li>Brute Force <blockquote class="doxtable">
<p>Gera permutações de todos os caminhos possíveis e verifica dentre eles qual forma um ciclo e dos que formam um ciclo qual tem a menor distância </p>
</blockquote>
</li>
<li>Branch and Bound <blockquote class="doxtable">
<p>Gera uma árvore com todos os caminhos testando todas as ramificações parciais e podando aquelas que já são maiores que a solução atual. </p>
</blockquote>
</li>
<li>Dynamic Programming</li>
<li>Genetic Algorithm</li>
</ul>
<h2>2) Implementação:</h2>
<h3>Descrição</h3>
<p>Como o problema envolve naturalmente a estrutura de dados Grafo, todos os algoritmos a usam. Neste trabalho criamos uma classe <a class="el" href="classTSP.html">TSP</a> (Traveling Salesman Problem) que serve como uma classe abstrata e classe base para os outros algoritmos que também são representados por classes.</p>
<h3>Detalhes de implementação</h3>
<h3>Branch and Bound</h3>
<p>Similar ao Brute Force, o Branch and Bound gera uma árvore de recursão com diversos caminhos para seguir. Entretanto, não gera todas as possibilidades para descobrir o melhor caminho, mas, a cada cidade que avança, o algoritmo compara se a soma das arestas passadas é maior que o melhor caminho atual. Caso o teste seja verdadeiro, o cálculo é abortado e o programa testa outro caminho na árvore de recursão descartando, assim, vários outros testes desnecessários.</p>
<p>A função principal do algoritmo possui os seguintes parâmetros:</p>
<ul>
<li><code>double **matriz</code>: ponteiro para a matriz de adjacência(grafo);</li>
<li><code>double parcial</code>: tamanho do caminho parcial;</li>
<li><code>int nivel</code>: nível atual da árvore de recursão;</li>
<li><code>int *caminho_parcial</code>: ponteiro para vetor com os vértices do caminho atual na árvore de recursão;</li>
<li><code>bool *visitados</code>: ponteiro para vetor que representa vértices visitados;</li>
</ul>
<p>O algoritmo começa inicializando os vetores <code>caminho_parcial</code> e <code>visitados</code>. Logo após, passamos todos os parâmetros para o método principal. Sendo que <code>parcial</code> é inicializado com <code>0</code> e o <code>nivel</code> se inicia com <code>1</code>. Assim, finalizadas as inicializações, podemos começar a analisar o método. A ideia é bastante simples. No início do método, é testado se o algoritmo chegou ao último nível da árvore de recursão. Caso seja verdadeiro, se houver caminho direto até a raiz, somamos este caminho ao caminho parcial e testamos se esta soma é menor que a menor distância anterior. Se este teste também for verdadeiro, o vetor com o melhor caminho é atualizado e o seu custo é armazenado para futuras comparações. Veja abaixo o trecho:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (nivel == vertices)</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (matriz[nivelAnterior][caminhoParcial[0]] != <a class="code" href="constants_8h.html#a2dc3870be25a19efa2940150507aaf71">UNDEFINED</a>)</div><div class="line">   {</div><div class="line">      <span class="keywordtype">double</span> resultadoAtual =</div><div class="line">         parcial + matriz[nivelAnterior][caminhoParcial[0]];</div><div class="line">         <span class="keywordflow">if</span> (resultadoAtual &lt; this→distance)</div><div class="line">         {</div><div class="line">            atualizarMelhorCaminho(caminhoParcial);</div><div class="line">            this-&gt;distance = resultadoAtual;</div><div class="line">         }</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>Caso o algoritmo ainda não estiver no fim da árvore, o primeiro “if” será falso e, assim, cairemos no “else”. Este bloco possui um “for” que passa por todos os vértices ainda não visitados. Em sua estrutura, temos uma chamada recursiva que é requisitada caso o custo do caminho parcial até o momento, <code>parcial</code>, seja menor que o custo do menor caminho atual. Porém, se esse teste for falso, ou seja, se o percorrido até este momento já é <code>maior</code> que o menor caminho armazenado, o teste falha e, portanto, descartamos computações desnecessárias.</p>
<p>Veja o código abaixo:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; vertices; x++)</div><div class="line">{</div><div class="line">   <span class="keywordflow">if</span> (!visitados[x] &amp;&amp; matriz[nivelAnterior][x] != <a class="code" href="constants_8h.html#a2dc3870be25a19efa2940150507aaf71">UNDEFINED</a>)</div><div class="line">   {</div><div class="line">      parcial += matriz[nivelAnterior][x];</div><div class="line">      <span class="keywordflow">if</span> (parcial &lt; this→distance)</div><div class="line">      {</div><div class="line">         caminhoParcial[nivel] = x;</div><div class="line">         visitados[x] = <span class="keyword">true</span>;</div><div class="line">         branchAndBound(matriz, parcial, nivel + 1, caminhoParcial, visitados);</div><div class="line">      }</div><div class="line">      parcial -= matriz[nivelAnterior][x];</div><div class="line">      memset(visitados, <span class="keyword">false</span>, vertices);</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; nivel; y++)</div><div class="line">         visitados[caminhoParcial[y]] = <span class="keyword">true</span>;</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><h3>Dynamic Programming</h3>
<p>Como a estrutura de dados e a forma de memoização desse algoritmo são mais peculiares, vou usar algumas imagens para ilustrar melhor o que foi feito.</p>
<div class="image">
<img src="https://i.imgur.com/AlKkj0A.png" alt="Árvore gerada pela recursividade"/>
</div>
<p>No caso dessa imagem, <code>g(i, S)</code> é uma função que calcula o menor custo possível para chegar no vértice <code>i</code> passando por todos os vértices do subconjunto <code>S</code>.</p>
<p>O truque da programação dinâmica aqui é que, por exemplo, o custo mínimo para chegar no vértice 1, passando pelos vértices 2 e 3, ou seja, <code>g(1, {2, 3})</code> é igual ao mínimo entre:</p>
<p>I) chegar no vértice 2, passando pelo vértice 3 e do vértice 2 ir para o 1 ou</p>
<p>II) chegar no vértice 3, passando pelo vértice 2 e do vértice 3 ir para o 1</p>
<p>porém "chegar no vértice 2, passando pelo vértice 3" é exatamente <code>g(2, {3})</code> e "chegar no vértice 3, passando pelo vértice 2" é exatamente <code>g(3, {2})</code>, ou seja, ao guardar a solução de problemas menores, consigo resolver problemas maiores.</p>
<p>No início do algoritmo eu já calculo o custo de todos caminhos que terminam em um vértice <code>v</code> qualquer e não precisam de passar por nenhum outro, ou seja, são chamadas à função g do tipo: <code>g(v, Ø)</code>. Nesse caso, o custo é o custo de sair de <code>v</code> e ir para o vértice inicial que é o 0. Ou seja, é a aresta entre esses dois vértices.</p>
<p>Faço isso nesse trecho de código, onde <code>memoTable[A][B]</code> significa <code>g(B, A)</code>.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> city = 1; city &lt; numCities; city++)</div><div class="line">    memoTable[0][city] = graph[city][0];</div></div><!-- fragment --><p>Em <code>memoTable</code>, eu indexo as linhas pelo subconjunto e as colunas pelo vértice final. Além disso, eu represento os subconjuntos por números inteiros que na verdade são pensados como números binários. Ou seja, ao ler 14, você deve imaginar 1110. E esse número indica quais cidades estão nesse subconjunto. Nesse caso, as cidades 1, 2 e 3. Ou seja, <code>memoTable[14][0]</code> indicaria o custo mínimo para chegar no vértice 0 passando pelas cidades 1, 2 e 3</p>
<p>Esse trecho é a execução do algoritmo de fato:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> newSubset = <a class="code" href="dynamicProgramming_8cpp.html#a5873ad8db1710ff49d7f3346364dd1ff">removeCity</a>(endingCity, citiesSubset);</div><div class="line"><span class="keywordtype">int</span> bestCost = <a class="code" href="constants_8h.html#a392fb874e547e582e9c66a08a1f23326">MAX</a>, cost = memoTable[newSubset][endingCity];</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (cost != <a class="code" href="constants_8h.html#a2dc3870be25a19efa2940150507aaf71">UNDEFINED</a>) <span class="keywordflow">return</span> cost;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> newEndingCity = 1; newEndingCity &lt; numCities; newEndingCity++)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="dynamicProgramming_8cpp.html#abc457dbe2d9cc27e359dd3dafaf93ddf">notIn</a>(newSubset, newEndingCity)) <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">    cost = <a class="code" href="dynamicProgramming_8cpp.html#a32fcc3bfa3c40dd25ea87b06854a81b8">dynamicTSP</a>(memoTable, graph, newSubset, newEndingCity, numCities) +</div><div class="line">            graph[newEndingCity][endingCity];</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (cost &lt; bestCost) bestCost = cost;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordflow">return</span> memoTable[newSubset][endingCity] = bestCost;</div></div><!-- fragment --><p>Ao receber um subconjunto de cidades (<code>citiesSubset</code>) e uma cidade final (<code>endingCity</code>), eu removo essa <code>endingCity</code> do subconjunto e vejo se já não existe o custo de chegar na <code>endingCity</code> passando pelo novo subconjunto gerado (<code>newSubset</code>) na memoTable. Caso sim eu posso retornar esse valor. Caso não, eu faço uma repetição por todas as cidades desse novo subconjunto (<code>newSubset</code>) e vou escolhendo cada uma delas para ser a nova cidade final (<code>newEndingCity</code>) do subconjunto. A <code>newEndingCity</code> que gerar o custo mínimo será a definitiva.</p>
<h3>Genetic Algorithm</h3>
<p>Esses dois trecho de código já explicam o funcionamento do algoritmo em geral. O primeiro trecho é o que eu considero como um indivíduo no algoritmo genético.</p>
<div class="fragment"><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="classIndividual.html">Individual</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    vector&lt;int&gt; <a class="code" href="classIndividual.html#ae2f81e93ccc1912072a16e020a6f11e1">cities</a>;</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="classIndividual.html#a5914963e5051863b470bf74379aac92a">pathCost</a> = -1;</div><div class="line">};</div></div><!-- fragment --><p>Já o segundo trecho é a execução do algoritmo de fato.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> numVertices = this-&gt;graph.getV();</div><div class="line"><span class="keywordtype">int</span> numGenerations = numVertices * numVertices;</div><div class="line"><span class="keywordtype">int</span> populationSize = numGenerations / 4;</div><div class="line"><span class="keywordflow">if</span> (populationSize &lt; 1) populationSize = 1;</div><div class="line"><span class="keywordtype">int</span> mutationRate = 50;</div><div class="line"></div><div class="line">createRandomPopulation(population, populationSize, numVertices, bestPath);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> generationNum = 1; generationNum &lt;= numGenerations; generationNum++)</div><div class="line">   mutatePopulation(population, mutationRate, numVertices, bestPath);</div></div><!-- fragment --><p>Inicialmente, calculo um número de gerações, o tamanho da população de indivíduos e a taxa de mutação. Daí eu crio uma população inicial de forma aleatória e depois começa a mutar a população de acordo com a taxa de mutação. Ao mutar a população inteira eu passo para a próxima geração. Um detalhe importante é que a função que muta um indivíduo faz várias tentativas até que ele se torne melhor do que era antes. No caso desse algoritmo, coloquei o número máximo de tentativas como 3.</p>
<h3>Formato de entrada e saída</h3>
<p>o formato de entrada e saída de dados, bem como decisões tomadas relativas aos casos e detalhes de especificação que porventura estejam omissos no enunciado.</p>
<h3>Ambiente computacional</h3>
<table class="doxtable">
<tr>
<th>Sistema Operacional </th><th>Compilador </th><th>Editor de Código  </th></tr>
<tr>
<td>Windows/Linux </td><td>gcc ou g++ que suporte c++14 </td><td>Visual Studio Code </td></tr>
</table>
<p>Para mais informações Linux/Mac:</p>
<p><code>./run.sh --help</code></p>
<p>Para mais informações Windows, caso não tenha ativado a execução de scripts no PowerShell, abra-o e rode <code>Set-ExecutionPolicy Bypass Process</code>.</p>
<p><code>./run.ps1 --help</code></p>
<p>Rodando todos os algoritmos Linux/Mac:</p>
<p><code>./run.sh branch brute dynamic genetic</code></p>
<p>Rodando todos os algoritmos Windows (PowerShell):</p>
<p><code>./run.ps1 branch brute dynamic genetic</code></p>
<h2>3) Análise de Complexidade:</h2>
<p>análise de complexidade do pior e do melhor caso de todas as funções do programa e também do programa principal. Essa análise pode ser feita de forma mais detalhada linha por linha, somando-se as complexidades ou de forma mais geral, explicando a complexidade da função como um todo. De qualquer forma, tem que ficar claro qual é a operação relevante e também as configurações de entrada que levam ao pior e ao melhor caso.</p>
<h2>4) Testes:</h2>
<p>descrever os testes realizados, mostrando a saída do programa além de eventuais análises e comparações que foram solicitadas no enunciado.</p>
<p>Em todos os gráficos, o eixo x é o número de cidades e o eixo y é o tempo gasto em milisegundos.</p>
<div class="image">
<img src="https://i.imgur.com/O8PazIL.png" alt="travelling salesman problem, branch and bound, brute force, dynamic programming, genetic algorithm"/>
</div>
<div class="image">
<img src="https://i.imgur.com/Ditn469.png" alt="travelling salesman problem, branch and bound, dynamic programming, genetic algorithm"/>
</div>
<div class="image">
<img src="https://i.imgur.com/IRRMCS8.png" alt="travelling salesman problem, dynamic programming, genetic algorithm"/>
</div>
<h2>5) Conclusão:</h2>
<p>O trabalho foi muito bom para o grupo. Pudemos melhorar nossas habilidades na programação de algoritmos e também melhorar o nosso raciocínio lógico.</p>
<p>As principais dificuldades que tivemos foram nos algoritmos de Branch and Bound e Dynamic Programming. Porém, foi muito interessante tentar enxergar a sobreposição de problemas no algoritmo de Dynamic Programming. Além disso, pensar em como guardar os resultados dos subproblemas também foi bem interessante.</p>
<h2>6) Bibliografia:</h2>
<h4>Força Bruta</h4>
<p><a href="https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/">https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/</a><br />
 <a href="https://www2.cs.sfu.ca/CourseCentral/125/tjd/tsp_example.html">https://www2.cs.sfu.ca/CourseCentral/125/tjd/tsp_example.html</a></p>
<h3>Branch and Bound</h3>
<p><a href="https://www.geeksforgeeks.org/traveling-salesman-problem-using-branch-and-bound-2/">https://www.geeksforgeeks.org/traveling-salesman-problem-using-branch-and-bound-2/</a><br />
 <a href="https://www.youtube.com/watch?v=1FEP_sNb62k">https://www.youtube.com/watch?v=1FEP_sNb62k</a><br />
</p>
<h4>Algoritmo Genético</h4>
<p><a href="https://www.geeksforgeeks.org/traveling-salesman-problem-using-genetic-algorithm/">https://www.geeksforgeeks.org/traveling-salesman-problem-using-genetic-algorithm/</a></p>
<h4>Programação Dinâmica</h4>
<p><a href="https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/">https://www.geeksforgeeks.org/travelling-salesman-problem-set-1/</a><br />
 <a href="https://www.youtube.com/watch?v=Q4zHb-Swzro">https://www.youtube.com/watch?v=Q4zHb-Swzro</a><br />
 <a href="https://www.youtube.com/watch?v=cY4HiiFHO1o">https://www.youtube.com/watch?v=cY4HiiFHO1o</a><br />
 <a href="https://www.youtube.com/watch?v=udEe7Cv3DqU">https://www.youtube.com/watch?v=udEe7Cv3DqU</a><br />
 <a href="https://www.youtube.com/watch?v=-JjA4BLQyqE">https://www.youtube.com/watch?v=-JjA4BLQyqE</a><br />
 <a href="https://www.youtube.com/watch?v=JE0JE8ce1V0">https://www.youtube.com/watch?v=JE0JE8ce1V0</a></p>
<h4>Gerais</h4>
<p><a href="https://www.geeksforgeeks.org/measure-execution-time-with-high-precision-in-c-c/">https://www.geeksforgeeks.org/measure-execution-time-with-high-precision-in-c-c/</a><br />
 <a href="https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/NPcompleto.html">https://www.ime.usp.br/~pf/analise_de_algoritmos/aulas/NPcompleto.html</a></p>
<h2>7) Anexos:</h2>
<h4>Repositório</h4>
<p><a href="https://github.com/mayconbj15/Traveling-Salesman-Problem">https://github.com/mayconbj15/Traveling-Salesman-Problem</a></p>
<h4>Planilha com os tempos de execução em milissegundos</h4>
<p><a href="https://1drv.ms/x/s!Am8Xz4TByWFRgRsalFp-Lx20WrRE?e=ACjofG">https://1drv.ms/x/s!Am8Xz4TByWFRgRsalFp-Lx20WrRE?e=ACjofG</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Gerado por &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
